### "ЧТО должно быть сделано" — важнее, чем "КАК это должно быть сделано"

Перед тем, как начать решать задачу, выбирается стратегия решения и инструменты. Что, если выбор инструмента на самом деле не был стопроцентно правильным?
Если неправильность выбора не вполне очевидна для исполнителя, он может потратить лишние усилия на попытки заставить работать неработающий инструмент вместо того, чтобы
переключиться на работающий. 

*Пример: тест Appium с одним сценарием исполнения должен работать как на Android, так и на iOS устройствах. Один из шагов теста — ввод слова в форму поиска Google Search. 
Для Android всё просто: у веб-элемента `searchForm` вызывается метод `sendKeys(searchItem, Keys.ENTER)`. Для iPad это также срабатывает. Для iPhone — уже нет! 
Я бесплодно трачу время на выяснение, как можно эмулировать нажатие `Keys.ENTER` для iPhone. Затем я смотрю, как коллеги решали саму проблему ввода в форму поиска на iPhone
и оказывается, что в этом случае возможно использовать `searchForm.sendKeys(searchItem)`, а затем `searchForm.submit()` — что, в свою очередь, не сработает для Android. 
Однако теперь у меня есть два ответа, КАК сделать то, ЧТО должно быть сделано, для каждой подзадачи, и этого достаточно для решения целой задачи.*

### Перед тем, как работать с унаследованными тестами, необходимо зафиксировать их состояние

Не стоит предполагать, что то, что "раньше работало" реально работает. Проверке подлежит всё, что получено от другого автора.

*Пример: передо мной стоит задача залить билд в удалённый репозиторий. В процессе сборки после часа прогона тестов тесты начинают падать, и сборка прерывается. Тесты, теоретически, должны были проходить на нескольких предыдущих билдах. В процессе расследования, на которое я также трачу определённое время, выясняется, что автор тестов, обнаружив среди них несколько нестабильных, "исправил ситуацию", добавив к ним комментарий `FLAKY`.*

### Для работы в команде используйте аккаунт Github, который везде ясно демонстрирует ваши имя и фамилию

На выяснение и запоминание того, что за человек YOLO_XoXo11, навносивший за вчера правок, уходят время и внимание коллег.

### Перед тем, как решить, что тест готов к коммиту, следует прогнать его локально несколько раз и убедиться, что его поведение не варьируется

Нестабильный тест бесполезен. Стабильность поведения теста проверяется только множественными запусками: недостаточно один раз посмотреть на зелёную галочку и решить, что тест стабилен. Поэтому перед коммитом нужно прогонять тесты по несколько раз, по ситуации замеряя значения переменных, которые могут варьироваться. Лучше потратить на это время перед коммитом, чем потом расследовать причины нестабильности и чинить тесты.

### Если вы хотите, чтобы ваш open source проект поддерживали другие люди, позаботьтесь о том, чтобы им было легко в нём разобраться

Если можно сделать код яснее, он должен быть сделан яснее. Это универсальный совет, но в упомянутой ситуации он ценен вдвойне. Чем более запутан код, тем меньше стимул в нём разбираться. И даже если люди имеют стимул разбираться в нём и хотят его поддерживать, запутанный код будет отнимать время на вникание в него у каждого нового человека, занимающегося поддержкой. Кроме того, чем больше в проекте задействовано технологий, тем в целом выше требования к тем, кто будет заниматься его дальнейшей поддержкой. Если можно реализовать идею простыми средствами, реализуйте её простыми средствами.

### Если вы хотите, чтобы ваши интерфейсы имплементировали, потрудитесь объяснить, что должны представлять собой их методы

Неясное описание одного метода интерфейса в худшем (читай "вполне вероятном") случае может привести к тому, что интерфейс не будет имплементирован целиком. Если вы полагаетесь на названия методов, подумайте, является ли каждое в действительности говорящим.

### Если вы хотите облегчить себе жизнь при именовании директорий/папок, не используйте пробелы

При работе из терминала пробелы в путях к файлам приходится экранировать (оформлять пути определённым образом, чтобы терминал воспринимал пробел как составляющую пути). И способы экранирования в зависимости от разновидности терминала могут отличаться. Чтобы не тратить время на экранирование, достаточно просто не использовать в названиях директорий пробел или использовать вместо него нижнее_подчёркивание.

### Если вы хотите избежать неприязни коллег-пользователей другой ОС, используйте платформонезависимые пути

При написании программы легко не обратить внимание на факт, что она, возможно, будет запускаться и отлаживаться на машинах коллег, использующих другие ОС. И если программа оперирует файловыми путями, вполне возможно, что прописанные пользователем Windows пути окажутся "сломаны" для пользователя Linux, и наоборот. Большинство языков программирования предлагают способы обойти эту проблему, и зачастую они не вносят много сложности (как pathlib в Python, например). 

### Если вы хотите сделать запуск скриптов инструментов платформонезависимым, попробуйте установить CLI инструмента

При запуске скрипта из определённого местоположения (скажем, 'node_modules/.bin/') может возникнуть ситуация, когда для Windows нужно будет, скажем, указать расширение .cmd (очевидно, неактуальное для Linux). В моём случае проблема возникла с allure и командой терминала, которая содержала 'node_modules/.bin/allure'. Решением в данном случае оказалось установить allure-commandline глобально, чтобы стало возможно использовать в команде вместо пути к местоположению просто 'allure'.

### Если вы участвуете в выборе инструмента для ведения тестовой документации, постарайтесь делать это на основании требований

Документацией, которой неудобно пользоваться для текущих задач, при возможности пользоваться не будут. И, несмотря на Agile-мантры типа "работающие тесты важнее документации", я считаю, что отсутствие тестовой документации или её бесполезность способны нанести урон процессу разработки и поддержки тестов. Требования могут помочь заранее ответить на вопросы об организации тестовой документации: будет ли удобно в ней ориентироваться как вашим коллегам, так и, например, управленцам? Нужно ли будут дополнительное обучение её использованию? Легко ли по ней понять, что покрыто тестами, а что нет? Легко ли понять, какие тесты автоматизированы, а какие нет; какие должны быть автоматизированы, какие нет? Наконец, до какой степени возможна будет интеграция инструмента с тестовым фреймворком?

### Если вы каждый день запускаете тесты, в ваших интересах сделать процесс запуска как можно более лёгким

Механизм запуска тестов во всех возможных вариациях (все тесты, комплекты тестов, произвольный одиночный тест; обычный режим, режим отладки; мобильные тесты, десктопные тесты; локальный запуск, удалённый запуск; запуск с параметрами по умолчанию/произвольными параметрами) — это самое главное, что есть в тестовом фреймворке. Об этом механизме необходимо как следует подумать, выбирая технологии для фреймворка, и его необходимо рефакторить до такого состояния, чтобы его использование было максимально удобным. С точки зрения психологии, чем сложнее этап подготовки, тем меньше стимул приступить к действию. 

### Если вы работаете в команде, некоторая унификация набора и настроек инструментов для всей команды будет полезна

В первую очередь это должно упрощать ситуацию, когда вы учитесь у более опытных коллег, ведь следить за их действиями и повторять их будет легче, если ваши инструменты не сильно различаются. Даже если речь идёт о чём-нибудь принципиально похожем вроде инструментов разработчика Google Chrome и Mozilla Firefox, небольшая разница в организации интерфейса всё равно будет оттягивать на себя ресурсы, необходимые на интерпретацию этой разницы. И чем ближе "экосистемы" коллег, тем легче им будет получить совет друг у друга. А когда будет необходимо воспроизвести определённый сценарий и в нём что-то пойдёт не так, то схожесть используемых инструментов и их настроек, скорее всего, позволит легче выявить, какой именно фактор или факторы повлияли на разницу результатов. Версии языка, комплектации инструмента (например, для IDE варианты community и ultimate), разновидности операционной системы — это может внести разницу очевидным образом, но потенциально её может внести вообще любая мелочь.

### Если вы ещё не полностью перешли с графического интерфейса операционной системы на командную строку, вам могут пригодиться ярлыки/ссылки

Ссылки в проводнике и на рабочем столе на наиболее востребованные папки и файлы экономят время и усилия, затрачиваемые на однотипные действия по их поиску и переходу к ним. Разумеется, за ссылками необходимо на минимальном уровне следить и время от времени убирать неактуальные, но на мой взгляд, это должно быть не сильно сложнее, чем периодически смахивать крошки с обеденного стола. При всё ещё заметном англоцентризме IT может быть актуально, например, оставить для себя ссылку на файл, названную на вашем родном языке, а программам предоставить обращаться к нему по его первоначальному названию на английском. Также, возможно, вам когда-то пригодится возможность оформить в виде ярлыка ссылку на адрес в интернете: у меня были случаи, когда было удобнее хранить ссылки на ресурсы, сопутствующие определённому модулю учебного курса, вместе с остальными материалами модуля (а не в менеджере закладок).
